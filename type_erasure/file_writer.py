import re
from subprocess import call

import clang_util
import util
from file_parser import FileProcessor
from parser_addition import extract_include_guard


friendly_type_erasure_prefix = '// Generated by friendly type erasure.\n' \
                               '// Manual changes to this file will be overwritten by the next update.\n\n'


def get_detail_namespace(data):
    if data.detail_namespace != '':
        return data.detail_namespace
    return data.current_struct.spelling + data.detail_extension


def is_header_file(filename):
    return filename.endswith('.hpp') or \
        filename.endswith('.hh') or \
        filename.endswith('.h')


def is_source_file(filename):
    return filename.endswith('.cpp')


def get_source_filename(filename):
    if filename.endswith('.hpp'):
        return filename.replace('.hpp','.cpp')
    if filename.endswith('.hh'):
        return filename.replace('.hh','.cpp')
    if filename.endswith('.h'):
        return filename.replace('.h','.cpp')
    return filename


def get_header_filenames(filename):
    if not filename.endswith('.cpp'):
        return [filename]
    return [filename.replace('.cpp', '.hpp'), filename.replace('.cpp', '.hh'), filename.replace('.cpp', '.h')]




class CppFileWriter(FileProcessor):
    def __init__(self, filename, base_indent, comments=None):
        self.filename = filename
        self.base_indent = base_indent
        self.comments = comments
        self.file_content = []
        self.open_namespaces = 0
        self.open_classes = 0
        self.namespace_indent = self.open_namespaces * base_indent
        self.class_indent = self.open_classes * base_indent
        self.include_guard = None
        self.current_struct_prefix = None

    def process_open_include_guard(self, filename):
        self.include_guard = extract_include_guard(filename)
        if self.include_guard is None:
            return None
        if self.comments is not None:
            if util.trim(self.include_guard) == '#pragma once':
                copyright_ = util.get_comment('', self.comments, self.include_guard)
            else:
                copyright_ = util.get_comment('', self.comments, self.include_guard[0])
            if copyright_ != '':
                self.file_content.append(copyright_ + '\n')
        self.file_content.append(self.include_guard)

    def process_close_include_guard(self):
        if self.include_guard is None:
            return
        trimmed_guard = util.trim(self.include_guard)
        if trimmed_guard != '#pragma once' and trimmed_guard != '':
            self.file_content.append('\n\n#endif')

    def process_headers(self, headers):
        for header in headers:
            self.file_content.append(header + '\n')
        if len(headers) > 0:
            self.file_content.append('\n')

    def process_open_namespace(self, namespace_name):
        namespace_prefix = 'namespace ' + namespace_name
        comment = util.get_comment('', self.comments, namespace_prefix)
        self.file_content.append(comment)
        self.file_content.append(self.namespace_indent + namespace_prefix + '\n')
        self.file_content.append(self.namespace_indent + '{' + '\n')
        self.open_namespaces += 1
        self.namespace_indent += self.base_indent

    def process_close_namespace(self):
        self.open_namespaces -= 1
        self.namespace_indent = self.open_namespaces * self.base_indent
        self.file_content.append(self.namespace_indent + '}\n')

    def process_open_class(self, data):
        self.current_struct_prefix = data.current_struct_prefix
        self.open_classes += 1
        self.class_indent += self.base_indent

    def process_close_class(self):
        self.current_struct_prefix = None
        self.open_classes -= 1
        self.class_indent = self.open_classes * self.base_indent

    def process_type_alias(self,data,cursor):
        type_alias = clang_util.get_type_alias_or_typedef(data.tu, cursor)
        self.append_comment(self.namespace_indent, type_alias)
        self.file_content.append(self.namespace_indent + self.class_indent + type_alias + '\n')

    def process_variable_declaration(self,data,cursor):
        variable_declaration = clang_util.get_variable_declaration(data.tu, cursor)
        self.append_comment(self.namespace_indent, variable_declaration)
        self.file_content.append(self.namespace_indent + self.class_indent + variable_declaration + '\n')

    def process_forward_declaration(self,data,cursor):
        class_prefix = clang_util.get_class_prefix(data.tu,cursor)
        self.append_comment(self.namespace_indent, class_prefix)
        self.file_content.append(self.namespace_indent + self.class_indent + class_prefix + '\n\n')

    def process_enum(self,data,cursor):
        enum_definition = clang_util.get_enum_definition(data.tu, cursor)
        self.append_comment(self.namespace_indent, enum_definition.replace('\n', ''))
        self.file_content.append(clang_util.format_enum_definition(self.namespace_indent + self.class_indent, self.base_indent, enum_definition)+'\n')

    def append_comment(self,indent,signature):
        self.file_content.append(get_comment(indent, self.comments, signature))

    def write_to_file(self):
        file_ = open(self.filename, 'w')
        file_.write( friendly_type_erasure_prefix )
        for line in self.file_content:
            file_.write(line)
        if self.file_content[-1] != '\n':
            file_.write('\n')
        file_.close()


class FormFileWriter(CppFileWriter):
    def __init__(self, filename, base_indent, comments=None):
        self.lines = None
        self.expansion_lines = None
        super(FormFileWriter,self).__init__(filename, base_indent, comments)

    def process_type_alias(self,data,cursor):
        if self.expansion_lines is None:
            super(HeaderOnlyVTableInterfaceFileWriter,self).process_type_alias(data, cursor)
            return
        if self.expansion_lines[1][0] == -1:
            return
        alias_or_typedef = clang_util.get_type_alias_or_typedef(data.tu, cursor)
        comment = util.get_comment(self.base_indent, self.comments, alias_or_typedef)
        if '{type_aliases}' in self.lines[self.expansion_lines[1][0]]:
            self.lines[self.expansion_lines[1][0]] = comment
        else:
            self.lines[self.expansion_lines[1][0]] += comment
        self.lines[self.expansion_lines[1][0]] += self.class_indent + alias_or_typedef

    def process_variable_declaration(self,data,cursor):
        if self.expansion_lines is None :
            super(HeaderOnlyVTableInterfaceFileWriter,self).process_variable_declaration(data, cursor)
            return
        if self.expansion_lines[1][0] == -1:
            return
        variable_declaration = clang_util.get_variable_declaration(data.tu, cursor)
        comment = util.get_comment(self.base_indent, self.comments, variable_declaration)
        if '{type_aliases}' in self.lines[self.expansion_lines[1][0]]:
            self.lines[self.expansion_lines[1][0]] = comment
        else:
            self.lines[self.expansion_lines[1][0]] += comment
        self.lines[self.expansion_lines[1][0]] += self.class_indent + variable_declaration

    def process_enum(self,data,cursor):
        # process non-nested enum
        if self.expansion_lines is None :
            super(HeaderOnlyVTableInterfaceFileWriter,self).process_enum(data, cursor)
            return
        if self.expansion_lines[1][0] == -1:
            return
        # process nested enum
        enum_definition = clang_util.get_enum_definition(data.tu, cursor)
        comment = util.get_comment(self.base_indent, self.comments, enum_definition)
        if '{type_aliases}' in self.lines[self.expansion_lines[1][0]]:
            self.lines[self.expansion_lines[1][0]] = comment
        else:
            self.lines[self.expansion_lines[1][0]] += comment
        self.lines[self.expansion_lines[1][0]] += clang_util.format_enum_definition(self.base_indent, self.base_indent, enum_definition)


def get_type_erased_function_pointer_type(function):
    split_arguments = function.argument_names.split(',')
    ptr_type = function.signature.replace(' ' + function.name + ' ', '(*)')
    for argument in split_arguments:
        if len(argument) > 0:
            ptr_type = ptr_type.replace(' ' + util.trim(argument), '')
    if function.is_const:
        ptr_type = re.sub('\)\s*const(\s+noexcept)*\s*', ') noexcept', ptr_type)
    return ptr_type


def get_execution_wrapper_function_type(function):
    void_ptr = 'void*'
    if len(function.argument_names) > 0:
        void_ptr += ','
    ptr_type = function.signature.replace(' ' + function.name + ' (', '(*)( ' + function.const_qualifier + void_ptr)
    split_arguments = function.argument_names.split(',')
    for argument in split_arguments:
        if len(argument) > 0:
            ptr_type = ptr_type.replace(' ' + util.trim(argument), '')
    if function.is_const:
        ptr_type = re.sub('\)\s*const(\s+noexcept)*\s*', ') noexcept', ptr_type)
    return ptr_type


def get_handle(line):
    handle_prefixes = [' ', '(', '<', '{', '[', 'const ']
    handle_extensions = [' ', '&', '*', '<', '>']
    handle_names = ['Handle', 'HandleBase']

    for extension in handle_extensions:
        for name in handle_names:
            candidate = name + extension
            if line.startswith(candidate):
                return candidate
            for prefix in handle_prefixes:
                candidate = prefix + name + extension
                if candidate in line:
                    return candidate
    return None


class DistributedFileWriter(FileProcessor):
    def __init__(self, header_filewriter, source_filewriter):
        self.header_filewriter = header_filewriter
        self.source_filewriter = source_filewriter

    def process_open_include_guard(self, filename):
        self.header_filewriter.process_open_include_guard(filename)
        self.source_filewriter.process_open_include_guard(filename)

    def process_close_include_guard(self):
        self.header_filewriter.process_close_include_guard()
        self.source_filewriter.process_close_include_guard()

    def process_headers(self, headers):
        self.header_filewriter.process_headers(headers)
        self.source_filewriter.process_headers(['#include "' + self.header_filewriter.filename + '"'])

    def process_open_namespace(self, namespace_name):
        self.header_filewriter.process_open_namespace(namespace_name)
        self.source_filewriter.process_open_namespace(namespace_name)

    def process_close_namespace(self):
        self.header_filewriter.process_close_namespace()
        self.source_filewriter.process_close_namespace()

    def process_open_class(self, data):
        self.header_filewriter.process_open_class(data)
        self.source_filewriter.process_open_class(data)

    def process_close_class(self):
        self.header_filewriter.process_close_class()
        self.source_filewriter.process_close_class()

    def process_function(self, data, cursor):
        self.header_filewriter.process_function(data, cursor)
        self.source_filewriter.process_function(data, cursor)

    def process_type_alias(self, data, cursor):
        self.header_filewriter.process_type_alias(data, cursor)

    def process_variable_declaration(self,data,cursor):
        self.header_filewriter.process_variable_declaration(data,cursor)

    def process_forward_declaration(self,data,cursor):
        self.header_filewriter.process_forward_declaration(data,cursor)

    def process_enum(self,data,cursor):
        self.header_filewriter.process_enum(data,cursor)

    def write_to_file(self):
        self.header_filewriter.write_to_file()
        self.source_filewriter.write_to_file()
